<html lang="en">
<head>
<title>Esrap</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Esrap">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
.node { visibility:hidden; height: 0px; }
  .menu { visibility:hidden; height: 0px; }
  .chapter { background-color:#e47700; padding: 0.2em; }
  .section { background-color:#e47700; padding: 0.2em; }
  .settitle { background-color:#e47700; }
  .contents { border: 2px solid black;
              margin: 1cm 1cm 1cm 1cm;
              padding-left: 3mm; }
  .lisp { padding: 0; margin: 0em; }
  body { padding: 2em 8em; font-family: sans-serif; }
  h1 { padding: 1em; text-align: center; }
  li { margin: 1em; }

--></style>
</head>
<body>
<h1 class="settitle">Esrap</h1>
In addition to regular Packrat / Parsing Grammar / TDPL features Esrap
supports
     <ul>
<li>dynamic redefinition of nonterminals
<li>inline grammars
<li>semantic predicates
<li>introspective facilities for development
<li>support for left-recursive rules
<li>functions as terminals
</ul>

   <p>Esrap is maintained by <a href="mailto:nikodemus@random-state.net">Nikodemus Siivola</a> and <a href="mailto:jmoringe@techfak.uni-bielefeld.de">Jan Moringen</a>.

   <p>Esrap is maintained in Git:
<pre class="example">     git clone -b stable git://github.com/scymtym/esrap.git
</pre>
   <p>will get you a local copy (omit <code>-b stable</code> to get the latest
development version).
<pre class="example">     <a href="http://github.com/scymtym/esrap">http://github.com/scymtym/esrap</a>
</pre>
   <p>is the GitHub project page.

   <p>Esrap is licenced under an MIT-style licence.

   <p>For more on packrat parsing, see
<a href="http://pdos.csail.mit.edu/~baford/packrat/thesis/">http://pdos.csail.mit.edu/~baford/packrat/thesis/</a> for Bryan Ford's 2002
thesis: &ldquo;Packrat Parsing: a Practical Linear Time Algorithm with Backtracking&rdquo;.

   <p>For left recursion support in packrat parsers, see
<a href="http://www.vpri.org/pdf/tr2007002_packrat.pdf">http://www.vpri.org/pdf/tr2007002_packrat.pdf</a> for A. Warth et al's
2008 paper: &ldquo;Packrat Parsers Can Support Left Recursion&rdquo;.

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_TOC0" href="#TOC0">1 Parsing Expressions</a>
<li><a name="toc_TOC14" href="#TOC14">2 Dictionary</a>
<ul>
<li><a href="#TOC15">2.1 Primary Interface</a>
<li><a href="#TOC16">2.2 Utilities</a>
<li><a href="#TOC17">2.3 Introspection and Intercession</a>
<li><a href="#TOC18">2.4 Error Conditions</a>
</li></ul>
</li></ul>
</div>

<h2 class="chapter"><a name="TOC0"></a>1 Parsing Expressions</h2>

<p>Parsing proceeds by matching text against parsing expressions.
Matching has three components: success vs failure, consumption of
input, and associated production.

   <p>Parsing expressions that fail never consume input. Parsing expressions
that succeed may or may not consume input.

   <p>A parsing expressions can be:

<h3 class="heading"><a name="TOC1"></a>Terminal</h3>

<p>A terminal is a character or a string of length one, which succeeds and
consumes a single character if that character matches the terminal.

   <p>Additionally, Esrap supports some pseudoterminals.

     <ul>
<li>The wild terminal symbol <code>character</code> always succeeds, consuming
and producing a single character.
<li>Expressions of the form <code>(character-ranges range ...)</code> match a
single character from the given range(s), consuming and producing that
character. A range can be either a list of the form <code>(#\start_char
#\stop_char)</code> or a single character.
<li>Multicharacter strings can be used to specify sequences of terminals:
<code>"foo"</code> succeeds and consumes input as if <code>(and #\f #\o
#\o)</code>. Produces the consumed string.
<li>Expressions of the form <code>(string length)</code> can be used to specify
sequences of arbitrary characters: <code>(string 2)</code> succeeds and
consumes input as if <code>(and character character)</code>. Produces the
consumed string.
</ul>

<h3 class="heading"><a name="TOC2"></a>Nonterminal</h3>

<p>Nonterminals are specified using symbols. A nonterminal symbol
succeeds if the parsing expression associated with it succeeds, and
consumes whatever the input that expression consumes.

   <p>The production of a nonterminal depends on the associated expression
and an optional transformation rule.

   <p>Nonterminals are defined using <code>defrule</code>.

   <p><em>Note: Currently all rules share the same namespace, so you
should not use symbols in the COMMON-LISP package or other shared
packages to name your rules unless you are certain there are no other
Esrap using components in your Lisp image. In a future version of
Esrap grammar objects will be introduced to allow multiple definitions
of nonterminals. Symbols in the COMMON-LISP package are specifically
reserved for use by Esrap.</em>

<h3 class="heading"><a name="TOC3"></a>Sequence</h3>

<pre class="lisp">     (and subexpression ...)
</pre>
   <p>A sequence succeeds if all subexpressions succeed, and consumes all
input consumed by the subexpressions. A sequence produces the
productions of its subexpressions as a list.

<h3 class="heading"><a name="TOC4"></a>Ordered Choice</h3>

<pre class="lisp">     (or subexpression ...)
</pre>
   <p>An ordered choice succeeds if any of the subexpressions succeeds, and
consumes all the input consumed by the successful subexpression. An
ordered choice produces whatever the successful subexpression
produces.

   <p>Subexpressions are checked strictly in the specified order, and once
a subexpression succeeds no further ones will be tried.

<h3 class="heading"><a name="TOC5"></a>Negation</h3>

<pre class="lisp">     (not subexpression)
</pre>
   <p>A negation succeeds if the subexpression fails, and consumes one character
of input. A negation produces the character it consumes.

<h3 class="heading"><a name="TOC6"></a>Greedy Repetition</h3>

<pre class="lisp">     (* subexpresssion)
</pre>
   <p>A greedy repetition always succeeds, consuming all input consumed by
applying subexpression repeatedly as long as it succeeds.

   <p>A greedy repetition produces the productions of the subexpression as a
list.

<h3 class="heading"><a name="TOC7"></a>Greedy Positive Repetition</h3>

<pre class="lisp">     (+ subexpresssion)
</pre>
   <p>A greedy repetition succeeds if subexpression succeeds at least once,
and consumes all input consumed by applying subexpression repeatedly
as long as it succeeds. A greedy positive repetition produces the
productions of the subexpression as a list.

<h3 class="heading"><a name="TOC8"></a>Optional</h3>

<pre class="lisp">     (? subexpression)
</pre>
   <p>Optionals always succeed, and consume whatever input the subexpression
consumes. An optional produces whatever the subexpression produces, or
<code>nil</code> if the subexpression does not succeed.

<h3 class="heading"><a name="TOC9"></a>Followed-By Predicate</h3>

<pre class="lisp">     (&amp; subexpression)
</pre>
   <p>A followed-by predicate succeeds if the subexpression succeeds, and
<em>consumes no input</em>. A followed-by predicate produces whatever
the subexpression produces.

<h3 class="heading"><a name="TOC10"></a>Not-Followed-By Predicate</h3>

<pre class="lisp">     (! subexpression)
</pre>
   <p>A not-followed-by predicate succeeds if the subexpression does not
succeed, and <em>consumes no input</em>. A not-followed-by predicate
produces <code>nil</code>.

<h3 class="heading"><a name="TOC11"></a>Semantic Predicates</h3>

<pre class="lisp">     (predicate-name subexpression)
</pre>
   <p>The <code>predicate-name</code> is a symbol naming a global function. A
semantic predicate succeeds if subexpression succeeds <em>and</em> the
named function returns true for the production of the subexpression. A
semantic predicate produces whatever the subexpression produces.

   <p><em>Note: semantic predicates may change in the future to produce
whatever the predicate function returns.</em>

<h3 class="heading"><a name="TOC12"></a>Functions as Terminals</h3>

<pre class="lisp">     (function function-name)
</pre>
   <p><code>function-name</code> is a symbol naming a global
function. <code>function-name</code>'s lambda-list has to be compatible to
<code>(text position end)</code> where <code>text</code> is the whole input and
<code>position</code> and <code>end</code> indicate the maximal subsequence
<code>function-name</code> should attempt to parse.

   <p>A function terminal succeeds if either
     <ol type=1 start=1>
<li><code>function-name</code> returns <code>T</code> as its third value.
<li><code>function-name</code> returns <code>nil</code> as its third value (or returns
only two values) and <code>nil</code> as its second value. This indicates that
the entire remaining input has been consumed.
<li><code>function-name</code> returns <code>nil</code> as its third value (or returns
only two values) and an integer <code>&gt; position</code> as its second value
indicating the position up to which <code>text</code> has been consumed.
        </ol>
When a function terminal succeeds, the first return value is an
arbitrary production.

   <p>A function terminal fails if either
     <ol type=1 start=1>
<li><code>function-name</code> returns two values: an ignored value and
<code>position</code>. Returning <code>position</code> indicates that no progress
has been made.
<li><code>function-name</code> returns three values: an ignored value, <code>nil</code>
or an integer <code>&gt;= position</code> and a string or a condition explaining
the failure. In this case, when the second value is not <code>nil</code>, it
indicates the exact position of the failure.
        </ol>

   <p>Note that rules which use functions as terminals do not automatically
pick up redefinitions of the used functions. For that to happen, the
rules have to be redefined as well.

   <p>See <samp><span class="file">example-function-terminals.lisp</span></samp> for examples.

<h3 class="heading"><a name="TOC13"></a>Left Recursion</h3>

<p>One aspect of designing Esrap rules is <em>left recursion</em>. A
<em>direct left recursive</em> rule is of the form
<pre class="lisp">     (defrule left-recursion (or (and left-recursion STUFF) ALTERNATIVES))
</pre>
   <p>The simplest <em>indirect left recursive</em> rule is of the form
<pre class="lisp">     (defrule left-recursion.1 left-recursion.2)
     (defrule left-recursion.2 (or (and left-recursion.1 STUFF) ALTERNATIVES))
</pre>
   <p>Esrap can handle both kinds of left recursive rules, but the linear-time
guarantee generally no longer holds in such cases. The special variable
<code>*on-left-recursion*</code> can be set to either <code>nil</code> or
<code>:error</code> to control Esrap's behavior with respect to allowing left
recursion.

   <p>See <samp><span class="file">example-left-recursion.lisp</span></samp> for examples.

<h2 class="chapter"><a name="TOC14"></a>2 Dictionary</h2>

<h3 class="section"><a name="TOC15"></a>2.1 Primary Interface</h3>

<p><a name="Macro-defrule"></a>

<div class="defun">
&mdash; Macro: <b>defrule</b><var> symbol expression &amp;body options<a name="index-defrule-1"></a></var><br>
<blockquote><p><a name="index-defrule-2"></a>Define <code>symbol</code> as a nonterminal, using <code>expression</code> as associated the parsing expression.

        <p>Multiple <code>options</code> specifying transforms are composed in the order of
appearance:

     <pre class="lisp">
            (:text t)
            (:function parse-integer)
            =&gt;
            (alexandria:compose #'parse-integer #'text)
</pre>
        <p>Following <code>options</code> can be specified:

          <ul>
<li><code>(:when test)</code>

          <p>The rule is active only when <code>test</code> evaluates to true. This can be used
    to specify optional extensions to a grammar.

          <p>This option can only be supplied once.

          <li><code>(:constant constant)</code>

          <p>No matter what input is consumed or what <code>expression</code> produces, the production
    of the rule is always <code>constant</code>.

          <li><code>(:function function)</code>

          <p>If provided the production of the expression is transformed using
    <code>function</code>. <code>function</code> can be a function name or a lambda-expression.

          <li><code>(:identity boolean)</code>

          <p>If true, the production of expression is used as-is, as if <code>(:function identity)</code>
    has been specified. If no production option is specified, this is the default.

          <li><code>(:text boolean)</code>

          <p>If true, the production of expression is flattened and concatenated into a string
    as if by <code>(:function text) </code>has been specified.

          <li><code>(:lambda lambda-list &amp;body body)</code>

          <p>If provided, same as using the corresponding lambda-expression with <code>:function</code>.

          <p>As an extension of the standard lambda list syntax, <code>lambda-list</code> accepts
    the optional pseudo lambda-list keyword <code>esrap:&amp;bounds</code>, which <code>(1) </code>must appear
    after all standard lambda list keywords. <code>(2) </code>can be followed by one or two
    variables to which bounding indexes of the matching substring are bound.

          <p>Therefore:

          <p><code>lambda-list</code> <code>::=</code> <code>(standard-lambda-list-elements [&amp;bounds start [end]])</code>

          <li><code>(:destructure destructuring-lambda-list &amp;body body)</code>

          <p>If provided, same as using a lambda-expression that destructures its argument
    using <code>destructuring-bind</code> and the provided lambda-list with <code>:function</code>.

          <p><code>destructuring-lambda-list</code> can use <code>esrap:&amp;bounds</code> in the same way
    as described for <code>:lambda</code>.

          <li><code>(:around ([&amp;bounds start [end]]) &amp;body body)</code>

          <p>If provided, execute <code>body</code> around the construction of the production of the
    rule. <code>body</code> has to call <code>esrap:call-transform</code> to trigger the computation of
    the production. Any transformation provided via <code>:lambda</code>, <code>:function</code>
    or <code>:destructure</code> is executed inside the call to <code>esrap:call-transform</code>. As a
    result, modification to the dynamic state are visible within the
    transform.

          <p><code>esrap:&amp;bounds</code> can be used in the same way as described for <code>:lambda</code>
    and <code>:destructure</code>.

          <p>This option can be used to safely track nesting depth, manage symbol
    tables or for other stack-like operations.
</ul>
        </p></blockquote></div>

   <p><a name="Function-parse"></a>

<div class="defun">
&mdash; Function: <b>parse</b><var> expression text &amp;key start end junk-allowed<a name="index-parse-3"></a></var><br>
<blockquote><p><a name="index-parse-4"></a>Parses <code>text</code> using <code>expression</code> from <code>start</code> to <code>end</code>.

        <p>Incomplete parses, that is not consuming the entirety of <code>text</code>, are
allowed only if <code>junk-allowed</code> is true.

        <p>Returns three values:

        <p>1) A production, if the parse succeeded, <code>nil</code> otherwise.
2) The position up to which <code>text</code> has been consumed or <code>nil</code> if the
   entirety of <code>text</code> has been consumed.
3) If the parse succeeded, even if it did not consume any input, <code>t</code> is
   returned as a third value.

        <p>The third return value is necessary to distinguish successful and
failed parses for cases like

     <pre class="lisp">
            (parse '(! #\a) "a" :junk-allowed t)
            (parse '(! #\a) "b" :junk-allowed t)
</pre>
        <p>in which the first two return values cannot indicate failures.
</p></blockquote></div>

   <p><a name="Function-describe_002dgrammar"></a>

<div class="defun">
&mdash; Function: <b>describe-grammar</b><var> symbol &amp;optional stream<a name="index-describe_002dgrammar-5"></a></var><br>
<blockquote><p><a name="index-describe_002dgrammar-6"></a>Prints the grammar tree rooted at nonterminal <code>symbol</code> to <code>stream</code> for human
inspection.
</p></blockquote></div>

<h3 class="section"><a name="TOC16"></a>2.2 Utilities</h3>

<p><a name="Function-text"></a>

<div class="defun">
&mdash; Function: <b>text</b><var> &amp;rest arguments<a name="index-text-7"></a></var><br>
<blockquote><p><a name="index-text-8"></a>Arguments must be strings, or lists whose leaves are strings.
Catenates all the strings in arguments into a single string.
</p></blockquote></div>

<h3 class="section"><a name="TOC17"></a>2.3 Introspection and Intercession</h3>

<p><a name="Function-add_002drule"></a>

<div class="defun">
&mdash; Function: <b>add-rule</b><var> symbol rule<a name="index-add_002drule-9"></a></var><br>
<blockquote><p><a name="index-add_002drule-10"></a>Associates <code>rule</code> with the nonterminal <code>symbol</code>. Signals an error if the
rule is already associated with a nonterminal. If the symbol is already
associated with a rule, the old rule is removed first.
</p></blockquote></div>

   <p><a name="Function-change_002drule"></a>

<div class="defun">
&mdash; Function: <b>change-rule</b><var> symbol expression<a name="index-change_002drule-11"></a></var><br>
<blockquote><p><a name="index-change_002drule-12"></a>Modifies the nonterminal <code>symbol</code> to use <code>expression</code> instead. Temporarily
removes the rule while it is being modified.
</p></blockquote></div>

   <p><a name="Function-find_002drule"></a>

<div class="defun">
&mdash; Function: <b>find-rule</b><var> symbol<a name="index-find_002drule-13"></a></var><br>
<blockquote><p><a name="index-find_002drule-14"></a>Returns rule designated by <code>symbol</code>, if any. Symbol must be a nonterminal
symbol.
</p></blockquote></div>

   <p><a name="Function-remove_002drule"></a>

<div class="defun">
&mdash; Function: <b>remove-rule</b><var> symbol &amp;key force<a name="index-remove_002drule-15"></a></var><br>
<blockquote><p><a name="index-remove_002drule-16"></a>Makes the nonterminal <code>symbol</code> undefined. If the nonterminal is defined an
already referred to by other rules, an error is signalled unless <code>:force</code> is
true.
</p></blockquote></div>

   <p><a name="Function-rule_002ddependencies"></a>

<div class="defun">
&mdash; Function: <b>rule-dependencies</b><var> rule<a name="index-rule_002ddependencies-17"></a></var><br>
<blockquote><p><a name="index-rule_002ddependencies-18"></a>Returns the dependencies of the <code>rule:</code> primary value is a list of defined
nonterminal symbols, and secondary value is a list of undefined nonterminal
symbols.
</p></blockquote></div>

   <p><a name="Function-rule_002dexpression"></a>

<div class="defun">
&mdash; Function: <b>rule-expression</b><var> rule<a name="index-rule_002dexpression-19"></a></var><br>
<blockquote><p><a name="index-rule_002dexpression-20"></a>Return the parsing expression associated with the <code>rule</code>.
</p></blockquote></div>

   <p><a name="Function-_0028setf-rule_002dexpression_0029"></a>

<div class="defun">
&mdash; Function: <b>(setf rule-expression)</b><var> expression rule<a name="index-g_t_0028setf-rule_002dexpression_0029-21"></a></var><br>
<blockquote><p><a name="index-g_t_0028setf-rule_002dexpression_0029-22"></a>Modify <code>rule</code> to use <code>expression</code> as the parsing expression. The rule must be
detached beforehand.
</p></blockquote></div>

   <p><a name="Function-rule_002dsymbol"></a>

<div class="defun">
&mdash; Function: <b>rule-symbol</b><var> rule<a name="index-rule_002dsymbol-23"></a></var><br>
<blockquote><p><a name="index-rule_002dsymbol-24"></a>Returns the nonterminal associated with the <code>rule</code>, or <code>nil</code> of the rule
is not attached to any nonterminal.
</p></blockquote></div>

   <p><a name="Function-trace_002drule"></a>

<div class="defun">
&mdash; Function: <b>trace-rule</b><var> symbol &amp;key recursive break<a name="index-trace_002drule-25"></a></var><br>
<blockquote><p><a name="index-trace_002drule-26"></a>Turn on tracing of nonterminal <code>symbol</code>. If <code>recursive</code> is true, turn
on tracing for the whole grammar rooted at <code>symbol</code>. If <code>break</code> is true,
break is entered when the rule is invoked.
</p></blockquote></div>

   <p><a name="Function-untrace_002drule"></a>

<div class="defun">
&mdash; Function: <b>untrace-rule</b><var> symbol &amp;key recursive break<a name="index-untrace_002drule-27"></a></var><br>
<blockquote><p><a name="index-untrace_002drule-28"></a>Turn off tracing of nonterminal <code>symbol</code>. If <code>recursive</code> is true, untraces the
whole grammar rooted at <code>symbol</code>. <code>break</code> is ignored, and is provided only for
symmetry with <code>trace-rule</code>.
</p></blockquote></div>

<h3 class="section"><a name="TOC18"></a>2.4 Error Conditions</h3>

<p><a name="Variable-_002aon_002dleft_002drecursion_002a"></a>

<div class="defun">
&mdash; Variable: <b>*on-left-recursion*</b><var><a name="index-g_t_002aon_002dleft_002drecursion_002a-29"></a></var><br>
<blockquote><p><a name="index-g_t_002aon_002dleft_002drecursion_002a-30"></a>This special variable controls Esrap's behavior with respect to
allowing left recursion.

        <p>When <code>:error</code>, <code>parse</code> signals a <code>left-recursion</code> error when it encounters a
left recursive rule. Otherwise the rule is processed.

        <p>Note: when processing left recursive rules, linear-time guarantees
generally no longer hold.
</p></blockquote></div>

   <p><a name="Condition-esrap_002derror"></a>

<div class="defun">
&mdash; Condition: <b>esrap-error</b><var><a name="index-esrap_002derror-31"></a></var><br>
<blockquote><p><a name="index-esrap_002derror-32"></a>Class precedence list: <code>esrap-error, parse-error, error, serious-condition, condition, t</code>

        <p>Signaled when an Esrap parse fails. Use <code>esrap-error-text</code> to obtain the
string that was being parsed, and <code>esrap-error-position</code> the position at which
the error occurred.
</p></blockquote></div>

   <p><a name="Condition-left_002drecursion"></a>

<div class="defun">
&mdash; Condition: <b>left-recursion</b><var><a name="index-left_002drecursion-33"></a></var><br>
<blockquote><p><a name="index-left_002drecursion-34"></a>Class precedence list: <code>left-recursion, esrap-error, parse-error, error, serious-condition, condition, t</code>

        <p>May be signaled when left recursion is detected during Esrap parsing.

        <p><code>left-recursion-nonterminal</code> names the symbol for which left recursion
was detected, and <code>left-recursion-path</code> lists nonterminals of which the
left recursion cycle consists.

        <p>Note: This error is only signaled if <code>*on-left-recursion*</code> is bound
to <code>:error</code>.
</p></blockquote></div>

</body></html>
